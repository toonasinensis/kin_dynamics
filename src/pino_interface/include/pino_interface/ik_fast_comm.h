/// autogenerated analytical inverse kinematics code from ikfast program part of
/// OpenRAVE \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
///
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x1000004a generated on 2023-12-02 05:59:27.751174
/// Generated using solver translation3d
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need
/// -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared
///     -Wl,-soname,libik.so -o libik.so ik.cpp
#pragma once
#define IKFAST_HAS_LIBRARY
// #include "el_mini_inv_kin.h"
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h

using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION == 0x1000004a);

#include <algorithm>
#include <cmath>
#include <complex>
#include <limits>
#include <vector>

#ifndef IKFAST_ASSERT
#include <iostream>
#include <sstream>
#include <stdexcept>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b)                                                       \
  {                                                                            \
    if (!(b)) {                                                                \
      std::stringstream ss;                                                    \
      ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": "        \
         << __PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed";        \
      throw std::runtime_error(ss.str());                                      \
    }                                                                          \
  }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI ((IkReal)6.28318530717959)
#define IKPI ((IkReal)3.14159265358979)
#define IKPI_2 ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
// #ifndef isfinite
// #define isfinite _isfinite
// #endif
#endif // _MSC_VER

// lapack routines
extern "C" {
void dgetrf_(const int *m, const int *n, double *a, const int *lda, int *ipiv,
             int *info);
void zgetrf_(const int *m, const int *n, std::complex<double> *a,
             const int *lda, int *ipiv, int *info);
void dgetri_(const int *n, const double *a, const int *lda, int *ipiv,
             double *work, const int *lwork, int *info);
void dgesv_(const int *n, const int *nrhs, double *a, const int *lda, int *ipiv,
            double *b, const int *ldb, int *info);
void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a,
             const int *lda, int *ipiv, double *b, const int *ldb, int *info);
void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a,
            const int *lda, double *wr, double *wi, double *vl, const int *ldvl,
            double *vr, const int *ldvr, double *work, const int *lwork,
            int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f * f; }
inline double IKsqr(double f) { return f * f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for
// branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than
// thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0.
// This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.00001)
#endif

inline float IKasin(float f) {
  IKFAST_ASSERT(
      f > -1 - IKFAST_SINCOS_THRESH &&
      f < 1 + IKFAST_SINCOS_THRESH); // any more error implies something is
                                     // wrong with the solver
  if (f <= -1)
    return float(-IKPI_2);
  else if (f >= 1)
    return float(IKPI_2);
  return asinf(f);
}
inline double IKasin(double f) {
  IKFAST_ASSERT(
      f > -1 - IKFAST_SINCOS_THRESH &&
      f < 1 + IKFAST_SINCOS_THRESH); // any more error implies something is
                                     // wrong with the solver
  if (f <= -1)
    return -IKPI_2;
  else if (f >= 1)
    return IKPI_2;
  return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y) {
  while (x < 0) {
    x += y;
  }
  return fmodf(x, y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y) {
  while (x < 0) {
    x += y;
  }
  return fmod(x, y);
}

inline float IKacos(float f) {
  IKFAST_ASSERT(
      f > -1 - IKFAST_SINCOS_THRESH &&
      f < 1 + IKFAST_SINCOS_THRESH); // any more error implies something is
                                     // wrong with the solver
  if (f <= -1)
    return float(IKPI);
  else if (f >= 1)
    return float(0);
  return acosf(f);
}
inline double IKacos(double f) {
  IKFAST_ASSERT(
      f > -1 - IKFAST_SINCOS_THRESH &&
      f < 1 + IKFAST_SINCOS_THRESH); // any more error implies something is
                                     // wrong with the solver
  if (f <= -1)
    return IKPI;
  else if (f >= 1)
    return 0;
  return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) {
  if (f <= 0.0f)
    return 0.0f;
  return sqrtf(f);
}
inline double IKsqrt(double f) {
  if (f <= 0.0)
    return 0.0;
  return sqrt(f);
}
inline float IKatan2Simple(float fy, float fx) { return atan2f(fy, fx); }
inline float IKatan2(float fy, float fx) {
  if (isnan(fy)) {
    IKFAST_ASSERT(
        !isnan(fx)); // if both are nan, probably wrong value will be returned
    return float(IKPI_2);
  } else if (isnan(fx)) {
    return 0;
  }
  return atan2f(fy, fx);
}
inline double IKatan2Simple(double fy, double fx) { return atan2(fy, fx); }
inline double IKatan2(double fy, double fx) {
  if (isnan(fy)) {
    IKFAST_ASSERT(
        !isnan(fx)); // if both are nan, probably wrong value will be returned
    return IKPI_2;
  } else if (isnan(fx)) {
    return 0;
  }
  return atan2(fy, fx);
}

template <typename T> struct CheckValue {
  T value;
  bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon) {
  CheckValue<T> ret;
  ret.valid = false;
  ret.value = 0;
  if (!isnan(fy) && !isnan(fx)) {
    if (IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH ||
        IKabs(fx) > IKFAST_ATAN2_MAGTHRESH) {
      ret.value = IKatan2Simple(fy, fx);
      ret.valid = true;
    }
  }
  return ret;
}

inline float IKsign(float f) {
  if (f > 0) {
    return float(1);
  } else if (f < 0) {
    return float(-1);
  }
  return 0;
}

inline double IKsign(double f) {
  if (f > 0) {
    return 1.0;
  } else if (f < 0) {
    return -1.0;
  }
  return 0;
}

template <typename T> inline CheckValue<T> IKPowWithIntegerCheck(T f, int n) {
  CheckValue<T> ret;
  ret.valid = true;
  if (n == 0) {
    ret.value = 1.0;
    return ret;
  } else if (n == 1) {
    ret.value = f;
    return ret;
  } else if (n < 0) {
    if (f == 0) {
      ret.valid = false;
      ret.value = (T)1.0e30;
      return ret;
    }
    if (n == -1) {
      ret.value = T(1.0) / f;
      return ret;
    }
  }

  int num = n > 0 ? n : -n;
  if (num == 2) {
    ret.value = f * f;
  } else if (num == 3) {
    ret.value = f * f * f;
  } else {
    ret.value = 1.0;
    while (num > 0) {
      if (num & 1) {
        ret.value *= f;
      }
      num >>= 1;
      f *= f;
    }
  }

  if (n < 0) {
    ret.value = T(1.0) / ret.value;
  }
  return ret;
}

inline IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

inline IKFAST_API int GetIkType() { return 0x33000003; }

inline IKFAST_API const char *GetIkFastVersion() { return "0x1000004a"; }

/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool el_mini_ComputeIK_left(const IkReal *eetrans,
                                       const IkReal *eerot, const IkReal *pfree,
                                       IkSolutionListBase<IkReal> &solutions);
/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool el_mini_ComputeIK_right(const IkReal *eetrans,
                                        const IkReal *eerot,
                                        const IkReal *pfree,
                                        IkSolutionListBase<IkReal> &solutions);

IKFAST_API bool el_mini_ComputeIk_lb(const IkReal *eetrans, const IkReal *eerot,
                                     const IkReal *pfree,
                                     IkSolutionListBase<IkReal> &solutions);

/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool el_mini_ComputeIK_rb(const IkReal *eetrans, const IkReal *eerot,
                                     const IkReal *pfree,
                                     IkSolutionListBase<IkReal> &solutions);

inline int GetNumJoints() { return 3; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif
